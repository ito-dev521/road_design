<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>道路設計管理システム</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/index.css">
</head>
<body>
    <div class="container">
        <!-- ヘッダー -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">🚧</div>
                <div class="logo-text">
                    <h1>道路設計管理システム</h1>
                    <p>Road Design Management System</p>
            </div>
            </div>
            <div class="header-actions">
                <div class="user-info">
                    <div class="user-details">
                        <span class="user-name" id="userName">読み込み中...</span>
                        <span class="user-role" id="userRole">読み込み中...</span>
                </div>
                </div>
                <a href="settings.html" id="settingsBtn" class="btn btn-secondary" style="display:none;">⚙️ 設定</a>
                <a href="logout.php" class="btn btn-secondary">🚪 ログアウト</a>
            </div>
        </header>

        <!-- メインコンテンツ -->
        <main class="main-container">
            <!-- プロジェクト選択/作成エリア -->
            <section class="project-section">
                <div class="card">
                <div class="project-header">
                    <h2>プロジェクト管理</h2>
                        <button class="btn btn-primary" id="newProjectBtn">🚀 新規プロジェクト</button>
                </div>
                
                <div class="project-selector">
                    <select id="projectSelect" class="project-select">
                        <option value="">プロジェクトを選択してください</option>
                    </select>
                    </div>
                </div>
            </section>

            <!-- プロジェクト情報 -->
            <section class="project-info" id="projectInfo" style="display: none;">
                <div class="card">
                <div class="project-details">
                        <div class="project-header-row">
                    <h3 id="projectName"></h3>
                            <div class="project-actions">
                                <button class="btn btn-primary btn-small" id="editProjectBtn" onclick="editProject()">
                                    ✏️ プロジェクト編集
                                </button>
                                <button class="btn btn-secondary btn-small" id="refreshProjectBtn" onclick="refreshProjectData()" title="最新のテンプレート情報を取得">
                                    🔄 更新
                                </button>
                                <button class="btn btn-danger btn-small" id="deleteProjectBtn" onclick="deleteProject()">
                                    🗑️ プロジェクト削除
                                </button>
                            </div>
                        </div>
                    <div class="project-meta">
                        <span id="projectClientInfo"></span>
                        <span id="projectPeriod"></span>
                        <span class="project-status" id="projectStatus"></span>
                    </div>
                </div>
                
                <!-- 進捗サマリー -->
                <div class="progress-summary">
                    <div class="progress-card">
                        <div class="progress-number" id="totalTasks">0</div>
                        <div class="progress-label">総タスク数</div>
                    </div>
                    <div class="progress-card">
                        <div class="progress-number" id="completedTasks">0</div>
                        <div class="progress-label">完了済み</div>
                    </div>
                    <div class="progress-card">
                        <div class="progress-number" id="inProgressTasks">0</div>
                        <div class="progress-label">進行中</div>
                    </div>
                    <div class="progress-card">
                        <div class="progress-number danger" id="needsConfirmationTasks">0</div>
                        <div class="progress-label">要確認</div>
                    </div>
                    <div class="progress-card">
                        <div class="progress-number danger" id="overdueTasks">0</div>
                        <div class="progress-label">遅延</div>
                    </div>
                </div>
                
                <!-- プログレスバー -->
                <div class="overall-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <span class="progress-text" id="progressText">0%</span>
                    </div>
                </div>
            </section>

            <!-- タスク管理 -->
            <section class="task-section" id="taskSection" style="display: none;">
                <div class="card">
                    <h3>タスク管理</h3>
                    
                    <!-- フェーズフィルター -->
                    <div class="task-filters" id="taskFilters">
                        <!-- フェーズボタンがここに動的に追加される -->
                </div>

                    <!-- タスクリスト -->
                    <div id="taskList" class="task-content">
                        <!-- タスクがここに動的に追加される -->
                    </div>
                </div>
            </section>
        </main>

        <!-- ローディング表示 -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">読み込み中...</div>
    </div>

        <!-- メッセージ表示 -->
        <div id="messageContainer" style="position: fixed; top: 20px; right: 20px; z-index: 2000;"></div>

        <!-- モーダルここに挿入される -->
        
        <!-- 新規プロジェクト作成モーダル -->
    <div class="modal-overlay" id="newProjectModal">
            <div class="modal project-modal">
            <div class="modal-header">
                    <h3 class="modal-title">新規プロジェクト作成</h3>
                    <button class="modal-close" onclick="closeNewProjectModal()">&times;</button>
            </div>
                <div class="modal-content">
            <form id="newProjectForm">
                        <div class="form-section">
                            <h4>プロジェクト基本情報</h4>
                            <div class="form-row">
                <div class="form-group">
                                    <label for="projectName">プロジェクト名</label>
                                    <input type="text" id="projectName" name="name" required>
                </div>
                <div class="form-group">
                                    <label for="newProjectClient">発注者</label>
                                    <select id="newProjectClient" name="client_id" required>
                                        <option value="">発注者を選択</option>
                                    </select>
                </div>
                            </div>
                            <div class="form-row">
                <div class="form-group">
                                    <label for="projectStartDate">開始日</label>
                                    <input type="date" id="projectStartDate" name="start_date" required>
                </div>
                <div class="form-group">
                                    <label for="projectEndDate">終了日</label>
                                    <input type="date" id="projectEndDate" name="end_date" required>
                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h4>テンプレート選択</h4>
                            <div class="template-selection">
                                <div class="template-filters" id="templateFilters">
                                    <!-- フェーズフィルターボタンがここに動的に追加される -->
                                </div>
                                <div class="template-list">
                                    <div class="template-groups" id="templateGroups">
                                        <!-- テンプレートがここに動的に追加される -->
                                    </div>
                                </div>
                                <div class="template-summary">
                                    <span>選択済み: <span id="selectedCount">0</span>件</span>
                                    <button type="button" class="btn btn-secondary" onclick="selectAllTemplates()">すべて選択</button>
                                    <button type="button" class="btn btn-secondary" onclick="deselectAllTemplates()">すべて解除</button>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="closeNewProjectModal()">キャンセル</button>
                    <button type="button" class="btn btn-primary" onclick="createProject()">プロジェクト作成</button>
                </div>
            </div>
        </div>

        <!-- プロジェクト編集モーダル -->
        <div class="modal-overlay" id="editProjectModal">
            <div class="modal project-modal">
                <div class="modal-header">
                    <h3 class="modal-title">プロジェクト編集</h3>
                    <button class="modal-close" onclick="closeEditProjectModal()">&times;</button>
                </div>
                <div class="modal-content">
                    <form id="editProjectForm">
                        <input type="hidden" id="editProjectId">
                        <div class="form-section">
                            <h4>プロジェクト基本情報</h4>
                <div class="form-row">
                    <div class="form-group">
                                    <label for="editProjectName">プロジェクト名</label>
                                    <input type="text" id="editProjectName" name="name" required>
                    </div>
                    <div class="form-group">
                                    <label for="editProjectClient">発注者</label>
                                    <select id="editProjectClient" name="client_id" required>
                                        <option value="">発注者を選択</option>
                                    </select>
                    </div>
                </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="editProjectStartDate">開始日</label>
                                    <input type="date" id="editProjectStartDate" name="start_date" required>
                                </div>
                                <div class="form-group">
                                    <label for="editProjectEndDate">終了日</label>
                                    <input type="date" id="editProjectEndDate" name="end_date" required>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="editProjectStatus">ステータス</label>
                                <select id="editProjectStatus" name="status" required>
                                    <option value="planning">計画中</option>
                                    <option value="in_progress">進行中</option>
                                    <option value="completed">完了</option>
                                    <option value="cancelled">中止</option>
                                </select>
                            </div>
                </div>
            </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="closeEditProjectModal()">キャンセル</button>
                    <button type="button" class="btn btn-primary" onclick="updateProject()">更新</button>
                </div>
        </div>
    </div>

        <!-- プロジェクト削除確認モーダル -->
        <div class="modal-overlay" id="deleteProjectModal">
            <div class="modal">
                <div class="modal-header">
                    <h3 class="modal-title">プロジェクト削除確認</h3>
                    <button class="modal-close" onclick="closeDeleteProjectModal()">&times;</button>
                </div>
                <div class="modal-content">
                    <div class="project-delete-info">
                        <strong>このプロジェクトを削除しますか？</strong>
                        <p id="deleteProjectInfo">プロジェクト名: <span id="deleteProjectName"></span></p>
                        <p style="color: #dc3545; font-weight: bold;">※ この操作は取り消せません。プロジェクトに関連するすべてのタスクも削除されます。</p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="closeDeleteProjectModal()">キャンセル</button>
                    <button type="button" class="btn btn-danger" onclick="confirmDeleteProject()">削除</button>
                </div>
            </div>
        </div>

        <!-- タスク編集モーダル -->
    <div class="modal-overlay" id="taskModal">
        <div class="modal task-modal">
            <div class="modal-header">
                    <h3 class="modal-title" id="taskModalTitle">タスク編集</h3>
                    <button class="modal-close" onclick="closeTaskModal()">&times;</button>
            </div>
                <div class="modal-content task-modal-content">
                    <form id="taskForm" onsubmit="return false;">
                        <input type="hidden" id="taskId">
                        
                        <!-- タスク基本情報 -->
                <div class="task-info">
                            <h4 id="taskTitle"></h4>
                        </div>
                        
                        <!-- タスクフォーム -->
                        <div class="task-form-row">
                    <div class="task-status-selector">
                                <label for="taskStatus">ステータス</label>
                                <select id="taskStatus" name="status" required>
                            <option value="not_started">未着手</option>
                            <option value="in_progress">進行中</option>
                            <option value="completed">完了</option>
                            <option value="needs_confirmation">要確認</option>
                            <option value="not_applicable">対象外</option>
                        </select>
                    </div>
                    <div class="task-assignment">
                                <label for="taskAssignee">担当者</label>
                                <select id="taskAssignee" name="assigned_to">
                            <option value="">未割当</option>
                        </select>
                    </div>
                    <div class="task-date">
                                <label for="taskDueDate">期限</label>
                                <input type="date" id="taskDueDate" name="due_date">
                            </div>
                    </div>
                    
                        <!-- タスク内容表示 -->
                        <div class="task-content">
                            <label>作業内容</label>
                            <div class="task-content-display" id="taskContentDisplay"></div>
                        </div>

                        <!-- タスクメタ情報 -->
                    <div class="task-meta">
                        <div class="task-meta-item">
                                <span class="meta-label">フェーズ:</span>
                                <span id="taskPhase"></span>
                            </div>
                            <div class="task-meta-item">
                                <span class="meta-label">作業順序:</span>
                                <span id="taskOrder"></span>
                            </div>
                            <div class="task-meta-item">
                                <span class="meta-label">技術作業:</span>
                            <span id="taskTechnical"></span>
                        </div>
                        <div class="task-meta-item">
                            <span class="meta-label">マニュアル:</span>
                                <span id="taskManualInfo"></span>
                                <div id="taskManualLinks" class="task-manual" style="margin-top:8px; display:none;">
                                    <div id="taskManualList"></div>
                                </div>
                    </div>
                </div>
                
                        <!-- 作業メモ -->
                <div class="task-notes">
                            <label>作業メモ</label>
                            
                            <!-- 既存メモの履歴 -->
                            <div class="notes-history" id="notesHistory">
                                <!-- メモ履歴がここに表示される -->
                </div>
                
                            <!-- 新しいメモ追加 -->
                            <div class="add-note-section">
                                <div class="note-input-container">
                                    <textarea id="newNote" placeholder="新しいメモを入力してください... (@でユーザーをメンションできます)" rows="4" title="@を入力するとユーザーをメンションできます。メンションすると自動的に要確認ステータスになります。"></textarea>
                                    <div id="userSuggestions" class="user-suggestions" style="display: none;"></div>
                                </div>
                                <button type="button" class="btn btn-primary" onclick="addNote()">メモを追加</button>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="closeTaskModal()">キャンセル</button>
                    <button type="button" class="btn btn-primary" onclick="saveTask()">保存</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentProject = null;
        let allTasks = [];
        let filteredTasks = [];
        let allPhases = [];
        let currentPhaseFilter = 'all';
        let allUsers = [];
        let allClients = [];
        let allTemplates = [];
        let selectedTemplateIds = new Set(); // 選択されたテンプレートIDを保持

        // 選択テンプレートの永続化
        function loadSelectedTemplatesFromStorage() {
            try {
                const raw = localStorage.getItem('selectedTemplateIds');
                if (raw) {
                    const arr = JSON.parse(raw);
                    if (Array.isArray(arr)) {
                        selectedTemplateIds = new Set(arr.map(String));
                    }
                }
            } catch (e) {
                console.warn('テンプレート選択の復元に失敗:', e);
            }
        }

        function saveSelectedTemplatesToStorage() {
            try {
                localStorage.setItem('selectedTemplateIds', JSON.stringify(Array.from(selectedTemplateIds)));
            } catch (e) {
                console.warn('テンプレート選択の保存に失敗:', e);
            }
        }

        // 新規プロジェクトモーダルの開閉状態・下書きの永続化
        function markNewProjectModalOpen(isOpen) {
            try { localStorage.setItem('newProjectModalOpen', isOpen ? 'true' : 'false'); } catch(e) {}
        }

        function saveNewProjectDraft() {
            try {
                const draft = {
                    name: document.getElementById('projectName')?.value || '',
                    client_id: document.getElementById('newProjectClient')?.value || '',
                    start_date: document.getElementById('projectStartDate')?.value || '',
                    end_date: document.getElementById('projectEndDate')?.value || ''
                };
                localStorage.setItem('newProjectDraft', JSON.stringify(draft));
            } catch (e) {
                console.warn('新規プロジェクト下書き保存に失敗:', e);
            }
        }

        function loadNewProjectDraft() {
            try {
                const raw = localStorage.getItem('newProjectDraft');
                if (!raw) return;
                const draft = JSON.parse(raw);
                if (!draft) return;
                if (draft.name) document.getElementById('projectName').value = draft.name;
                // クライアントはロード後に設定
                if (draft.start_date) document.getElementById('projectStartDate').value = draft.start_date;
                if (draft.end_date) document.getElementById('projectEndDate').value = draft.end_date;
                // クライアントは loadClients 完了後に適用
                setTimeout(() => {
                    if (draft.client_id) document.getElementById('newProjectClient').value = draft.client_id;
                }, 0);
            } catch (e) {
                console.warn('新規プロジェクト下書き復元に失敗:', e);
            }
        }

        // モーダル強制クローズ防止（保存/キャンセル以外では閉じない）
        let newProjectModalObserver = null;
        function startNewProjectModalGuard() {
            try {
                const modal = document.getElementById('newProjectModal');
                if (!modal) return;
                if (newProjectModalObserver) newProjectModalObserver.disconnect();
                newProjectModalObserver = new MutationObserver(() => {
                    const shouldBeOpen = localStorage.getItem('newProjectModalOpen') === 'true';
                    if (!shouldBeOpen) return;
                    // display/hidden が変更されていたら復元
                    if (modal.style.display === 'none' || modal.hidden) {
                        modal.style.display = 'block';
                        modal.hidden = false;
                    }
                });
                newProjectModalObserver.observe(modal, { attributes: true, attributeFilter: ['style', 'hidden'] });
            } catch (e) {
                console.warn('モーダルガード設定に失敗:', e);
            }
        }

        function stopNewProjectModalGuard() {
            try {
                if (newProjectModalObserver) newProjectModalObserver.disconnect();
                newProjectModalObserver = null;
            } catch (e) {}
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM読み込み完了');
            loadSelectedTemplatesFromStorage();
            // 一度開いていた場合は再表示
            if (localStorage.getItem('newProjectModalOpen') === 'true') {
                // 必要データ読み込み後に復元
                Promise.allSettled([loadClients(), loadPhases(), loadTemplates()]).then(() => {
                    loadNewProjectDraft();
                    document.getElementById('newProjectModal').style.display = 'block';
                    startNewProjectModalGuard();
                });
            }
            loadProjects();
            loadUserInfo();
            setupEventListeners();
        });

        // イベントリスナー設定
        function setupEventListeners() {
            // プロジェクト選択
            document.getElementById('projectSelect').addEventListener('change', function() {
                const projectId = this.value;
                if (projectId) {
                    // 選択されたプロジェクトをローカルストレージに保存
                    localStorage.setItem('selectedProjectId', projectId);
                    loadProject(projectId);
                } else {
                    // プロジェクト選択をクリア
                    localStorage.removeItem('selectedProjectId');
                    hideProjectInfo();
                }
            });

            // 新規プロジェクトボタン
            document.getElementById('newProjectBtn').addEventListener('click', function() {
                openNewProjectModal();
            });

            // モーダル背景クリックを無効化（モーダル内の要素は除外）
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', function(e) {
                    // モーダル内の要素がクリックされた場合は何もしない
                    if (e.target.closest('.modal')) {
                        return;
                    }
                    // 背景がクリックされた場合のみ無効化
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
            });

            // 入力変更の自動保存（新規プロジェクトフォーム）
            ['projectName','newProjectClient','projectStartDate','projectEndDate'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', saveNewProjectDraft);
                    el.addEventListener('change', saveNewProjectDraft);
                }
            });

            // タブ復帰時に新規プロジェクトモーダルを再表示
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && localStorage.getItem('newProjectModalOpen') === 'true') {
                    document.getElementById('newProjectModal').style.display = 'block';
                    loadNewProjectDraft();
                }
            });
        }

        // デフォルトユーザー情報設定
        function setDefaultUserInfo() {
            document.getElementById('userName').textContent = 'ゲスト';
            document.getElementById('userRole').textContent = 'ゲスト';
            console.log('デフォルトユーザー情報をゲストに設定しました');
            updateRoleBasedVisibility('guest');
        }

        // ユーザー情報読み込み
        async function loadUserInfo() {
            try {
                console.log('ユーザー情報を読み込み中...');
                
                // まず専用のプロフィールエンドポイントを試す
                const response = await fetch('api.php?path=user/profile&t=' + Date.now(), { cache: 'no-store' });
                const data = await response.json();
                
                console.log('プロフィールAPI応答:', data);
                
                if (data.success && data.name) {
                    document.getElementById('userName').textContent = data.name;
                    document.getElementById('userRole').textContent = getRoleText(data.role || 'guest');
                    // 設定ボタン表示制御
                    const settingsBtn = document.getElementById('settingsBtn');
                    if (settingsBtn) settingsBtn.style.display = (data.role === 'manager' || data.role === 'technical') ? 'inline-block' : 'none';
                    updateRoleBasedVisibility(data.role);
                    console.log('ユーザー情報設定完了:', data.name, data.role);
                } else {
                    console.log('ユーザー情報が取得できませんでした、デフォルト値を設定');
                    setDefaultUserInfo();
                }
            } catch (error) {
                console.error('ユーザー情報読み込みエラー:', error);
                console.log('代替手段を試行中...');
                
                // 代替手段を試行
                if (!await loadUserInfoAlternative()) {
                    setDefaultUserInfo();
                }
            }
        }

        // 代替ユーザー情報読み込み
        async function loadUserInfoAlternative() {
            try {
                const response = await fetch(`api.php?path=users&t=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();
                
                console.log('代替ユーザーAPI応答:', data);
                
                if (data.success && data.users && data.users.length > 0) {
                    // 最初のユーザー（通常は管理者）を使用
                    const user = data.users[0];
                    document.getElementById('userName').textContent = user.name;
                    document.getElementById('userRole').textContent = getRoleText(user.role);
                    const settingsBtn = document.getElementById('settingsBtn');
                    if (settingsBtn) settingsBtn.style.display = (user.role === 'manager' || user.role === 'technical') ? 'inline-block' : 'none';
                    updateRoleBasedVisibility(user.role);
                    console.log('代替手段でユーザー情報設定完了:', user.name, user.role);
                    return true;
                }
                
                console.log('代替手段でもユーザー情報を取得できませんでした');
                return false;
            } catch (error) {
                console.error('代替ユーザー情報読み込みエラー:', error);
                return false;
            }
        }

        // 役職名変換
        function getRoleText(role) {
            switch(role) {
                case 'manager': return '管理者';
                case 'technical': return '技術者';
                case 'general': return '一般';
                default: return 'ゲスト';
            }
        }

        // 役割に応じてプロジェクト操作ボタンを制御
        function updateRoleBasedVisibility(role) {
            const isGeneralOrGuest = !role || role === 'general' || role === 'guest';
            const createBtn = document.getElementById('newProjectBtn');
            const editBtn = document.getElementById('editProjectBtn');
            const deleteBtn = document.getElementById('deleteProjectBtn');
            if (createBtn) createBtn.style.display = isGeneralOrGuest ? 'none' : 'inline-block';
            if (editBtn) editBtn.style.display = isGeneralOrGuest ? 'none' : 'inline-block';
            if (deleteBtn) deleteBtn.style.display = isGeneralOrGuest ? 'none' : 'inline-block';
        }

        // プロジェクト一覧読み込み
        async function loadProjects() {
            try {
                console.log('プロジェクト一覧を読み込み中...');
                const response = await fetch(`api.php?path=projects&t=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();
                
                console.log('プロジェクトAPI応答:', data);
                
                if (data.success && data.projects) {
                    populateProjectSelect(data.projects);
                } else {
                    console.error('プロジェクト読み込みエラー:', data.error || 'データが見つかりません');
                    showMessage('プロジェクトの読み込みに失敗しました', 'error');
                }
            } catch (error) {
                console.error('プロジェクト読み込みエラー:', error);
                showMessage('プロジェクトの読み込み中にエラーが発生しました', 'error');
            }
        }

        // プロジェクト選択肢を設定
        function populateProjectSelect(projects) {
            const select = document.getElementById('projectSelect');
            select.innerHTML = '<option value="">プロジェクトを選択してください</option>';
            
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                select.appendChild(option);
            });
            
            // 保存されたプロジェクトを復元
            const savedProjectId = localStorage.getItem('selectedProjectId');
            if (savedProjectId) {
                // 保存されたプロジェクトが存在するかチェック
                const projectExists = projects.some(project => project.id == savedProjectId);
                if (projectExists) {
                    select.value = savedProjectId;
                    console.log('保存されたプロジェクトを復元:', savedProjectId);
                    // プロジェクトを自動的に読み込み
                    loadProject(savedProjectId);
                } else {
                    // 存在しないプロジェクトの場合はローカルストレージをクリア
                    localStorage.removeItem('selectedProjectId');
                    console.log('保存されたプロジェクトが存在しないため、選択をクリアしました');
                }
            }
            
            console.log(`${projects.length}個のプロジェクトを読み込みました`);
        }

        // プロジェクト読み込み
        async function loadProject(projectId) {
            try {
                showLoading();
                console.log('プロジェクトを読み込み中:', projectId);
                
                // プロジェクト詳細、タスク、フェーズを並行取得
                const [projectResponse, tasksResponse, phasesResponse] = await Promise.all([
                    fetch(`api.php?path=projects/${projectId}&t=${Date.now()}`, { cache: 'no-store' }),
                    fetch(`api.php?path=projects/${projectId}/tasks&t=${Date.now()}`, { cache: 'no-store' }),
                    fetch(`api.php?path=phases&t=${Date.now()}`, { cache: 'no-store' })
                ]);

                const [projectData, tasksData, phasesData] = await Promise.all([
                    projectResponse.json(),
                    tasksResponse.json(),
                    phasesResponse.json()
                ]);

                console.log('プロジェクトデータ:', projectData);
                console.log('タスクデータ:', tasksData);
                console.log('フェーズデータ:', phasesData);

                if (projectData.success && projectData.project) {
                    currentProject = projectData.project;
                    displayProject(currentProject);
                    
                    if (phasesData.success && phasesData.phases) {
                        allPhases = phasesData.phases;
                        setupPhaseFilters(allPhases);
                    }
                    
                    if (tasksData.success && tasksData.tasks) {
                        console.log('=== タスクデータ取得成功 ===');
                        console.log('タスクデータ取得成功:', tasksData.tasks);
                        console.log('タスクデータの詳細:', JSON.stringify(tasksData.tasks, null, 2));
                        
                        // 各タスクのステータス、担当者、期限を確認
                        tasksData.tasks.forEach((task, index) => {
                            console.log(`タスク${index + 1} (ID: ${task.id}):`, {
                                name: task.task_name || task.name,
                                status: task.status,
                                assigned_to: task.assigned_to,
                                assigned_to_name: task.assigned_to_name,
                                planned_date: task.planned_date
                            });
                        });
                        
                        allTasks = tasksData.tasks;
                        filteredTasks = [...allTasks]; // 直接コピー
                        console.log('filteredTasks 設定完了:', filteredTasks);
                        displayTasks(filteredTasks);
                        updateProgress();
                    } else {
                        console.log('タスクデータ取得失敗:', tasksData);
                        console.log('タスクデータの詳細:', JSON.stringify(tasksData, null, 2));
                        allTasks = [];
                        filteredTasks = [];
                        displayTasks([]);
                        updateProgress();
                    }
                    
                    showProjectInfo();
                } else {
                    console.error('プロジェクト読み込みエラー:', projectData.error);
                    showMessage('プロジェクトの読み込みに失敗しました', 'error');
                }
            } catch (error) {
                console.error('プロジェクト読み込みエラー:', error);
                showMessage('プロジェクトの読み込み中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }


        // プロジェクト情報表示
        function displayProject(project) {
            document.getElementById('projectName').textContent = project.name || '不明なプロジェクト';
            document.getElementById('projectClientInfo').textContent = `発注者: ${project.client_name || '不明'}`;
            const end = project.end_date || project.target_end_date || '';
            document.getElementById('projectPeriod').textContent = `期間: ${formatDate(project.start_date)} - ${formatDate(end)}`;
            document.getElementById('projectStatus').textContent = getStatusText(project.status);
            
            console.log('プロジェクト情報を表示しました:', project.name);
        }

        // プロジェクト情報表示/非表示
        function showProjectInfo() {
            document.getElementById('projectInfo').style.display = 'block';
            document.getElementById('taskSection').style.display = 'block';
        }

        function hideProjectInfo() {
            document.getElementById('projectInfo').style.display = 'none';
            document.getElementById('taskSection').style.display = 'none';
            currentProject = null;
            allTasks = [];
            filteredTasks = [];
        }

        // フェーズフィルター設定（現在の選択を維持）
        function setupPhaseFilters(phases) {
            const filtersContainer = document.getElementById('taskFilters');
            filtersContainer.innerHTML = '';

            if (phases.length > 0) {
                // 直近の選択を優先（ローカル保存があればそれも考慮）
                const savedPhaseId = localStorage.getItem('currentPhaseFilter');
                let desiredPhaseId = currentPhaseFilter || savedPhaseId;
                const exists = phases.some(p => String(p.id) === String(desiredPhaseId));
                if (!exists) {
                    desiredPhaseId = phases[0].id;
                }
                currentPhaseFilter = desiredPhaseId;

                // 各フェーズフィルター
                phases.forEach((phase) => {
                    const btn = document.createElement('button');
                    btn.className = String(phase.id) === String(currentPhaseFilter) ? 'filter-btn active' : 'filter-btn';
                    btn.textContent = phase.name;
                    btn.onclick = () => filterByPhase(phase.id);
                    filtersContainer.appendChild(btn);
                });
            }
        }

        // フェーズによるフィルタリング
        function filterByPhase(phaseId) {
            currentPhaseFilter = phaseId;
            try { localStorage.setItem('currentPhaseFilter', String(phaseId)); } catch (e) {}
            
            // フィルターボタンのアクティブ状態更新
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // 現在のボタンにactiveを付与
            const buttons = Array.from(document.querySelectorAll('.filter-btn'));
            const idx = buttons.findIndex(b => b.textContent === (allPhases.find(p => String(p.id) === String(phaseId))?.name));
            if (idx >= 0) {
                buttons[idx].classList.add('active');
            }

            displayTasks(filteredTasks);
        }

        // タスク表示
        function displayTasks(tasks) {
            console.log('displayTasks 呼び出し:', tasks);
            console.log('displayTasks の詳細:', JSON.stringify(tasks, null, 2));
            const taskList = document.getElementById('taskList');
            console.log('taskList 要素:', taskList);
            
            if (!tasks || tasks.length === 0) {
                console.log('タスクが空または未定義');
                taskList.innerHTML = '<div class="empty">タスクがありません</div>';
                return;
            }

            // フェーズによるフィルタリング
            let filteredByPhase = tasks.filter(task => {
                const phase = allPhases.find(p => p.name === task.phase_name);
                return phase && phase.id == currentPhaseFilter;
            });

            // フェーズごとにグループ化
            const tasksByPhase = {};
            filteredByPhase.forEach(task => {
                const phaseName = task.phase_name || '未分類';
                if (!tasksByPhase[phaseName]) {
                    tasksByPhase[phaseName] = [];
                }
                tasksByPhase[phaseName].push(task);
            });

            // フェーズごとに表示
            taskList.innerHTML = '';
            Object.entries(tasksByPhase).forEach(([phaseName, phaseTasks]) => {
                const phaseContainer = document.createElement('div');
                phaseContainer.className = 'phase-container';
                
                const phaseTitle = document.createElement('h3');
                phaseTitle.textContent = `${phaseName} (${phaseTasks.length})`;
                phaseContainer.appendChild(phaseTitle);
                
                const taskGrid = document.createElement('div');
                taskGrid.className = 'task-list';
                
                // タスクを順序でソート
                phaseTasks.sort((a, b) => (a.task_order || 0) - (b.task_order || 0));
                
                phaseTasks.forEach(task => {
                    const taskItem = createTaskItem(task);
                    taskGrid.appendChild(taskItem);
                });
                
                phaseContainer.appendChild(taskGrid);
                taskList.appendChild(phaseContainer);
            });

            console.log(`${filteredByPhase.length}個のタスクを表示しました`);
        }

        // タスクアイテム作成
        function createTaskItem(task) {
            console.log('createTaskItem called with task:', task);
            console.log('Task status:', task.status);
            
            const item = document.createElement('div');
            item.className = `task-item status-${task.status}`;
            item.onclick = () => editTask(task.id);
            
            const isOverdue = task.planned_date && new Date(task.planned_date) < new Date() && task.status !== 'completed';
            const isNeedsConfirmation = task.status === 'needs_confirmation';
            
            console.log('isNeedsConfirmation:', isNeedsConfirmation);
            console.log('Applied className:', item.className);
            console.log('Task status for CSS:', task.status);
            console.log('Task planned_date:', task.planned_date);
            console.log('Formatted date:', task.planned_date ? formatDate(task.planned_date) : '期限なし');
            
            // 要確認ステータスの場合、追加のデバッグ情報を出力
            if (isNeedsConfirmation) {
                console.log('要確認タスクを検出:', task);
                console.log('要素のクラス名:', item.className);
                console.log('要素のスタイル:', window.getComputedStyle(item));
            }
            
            // 要確認の場合の確認対象者を取得
            const confirmationTarget = isNeedsConfirmation ? getConfirmationTarget(task) : '';
            
            // 要確認ステータスの場合、直接スタイルを適用
            if (isNeedsConfirmation) {
                item.style.background = 'linear-gradient(135deg, #fff5f5, #ffe6e6)';
                item.style.border = '3px solid #ff0000';
                item.style.borderLeft = '6px solid #ff0000';
                item.style.boxShadow = '0 4px 15px rgba(255, 0, 0, 0.4)';
                item.style.transform = 'scale(1.02)';
                item.style.position = 'relative';
                item.style.zIndex = '10';
                console.log('要確認タスクに直接スタイルを適用しました');
            }

            // そのほかのステータスのカード色を明示（CSS未適用環境対策）
            if (!isNeedsConfirmation) {
                switch (task.status) {
                    case 'not_started':
                        item.style.background = '#f8f9fa';
                        item.style.borderLeft = '4px solid #6c757d';
                        break;
                    case 'in_progress':
                        item.style.background = '#fff8e1';
                        item.style.borderLeft = '4px solid #ffc107';
                        break;
                    case 'completed':
                        item.style.background = '#eaf7ee';
                        item.style.borderLeft = '4px solid #28a745';
                        break;
                    case 'not_applicable':
                        item.style.background = '#f1f3f5';
                        item.style.borderLeft = '4px solid #adb5bd';
                        item.style.opacity = '0.95';
                        break;
                }
            }
            
            item.innerHTML = `
                ${isNeedsConfirmation ? '<div style="position: absolute; top: -12px; right: 8px; background: #ff0000; color: white; padding: 6px 16px; border-radius: 16px; font-size: 0.8rem; font-weight: 700; box-shadow: 0 4px 8px rgba(255, 0, 0, 0.5); z-index: 1000; border: 2px solid white;">⚠️ 要確認</div>' : ''}
                <div class="task-header">
                    <h4 class="task-title">${task.task_name || task.name}</h4>
                    <div class="task-status-group">
                        <span class="task-status status-${task.status}">${getStatusText(task.status)}</span>
                        ${isOverdue ? '<span class="task-overdue">遅延</span>' : ''}
                    </div>
                </div>
                ${isNeedsConfirmation ? `
                <div style="background: rgba(255, 0, 0, 0.15); border: 2px solid #ff0000; border-radius: 12px; padding: 12px 16px; margin: 12px 0; display: flex; align-items: center; gap: 8px; box-shadow: 0 2px 8px rgba(255, 0, 0, 0.2);">
                    <span style="font-size: 1rem; color: #ff0000; font-weight: 700;">確認対象:</span>
                    <span style="font-size: 1.1rem; color: #cc0000; font-weight: 800; background: rgba(255, 0, 0, 0.3); padding: 4px 12px; border-radius: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);">${confirmationTarget}</span>
                </div>
                ` : ''}
                <div class="task-meta">
                    <div class="task-meta-row">
                        <div class="task-assignee">
                            <span class="icon-user"></span>
                            ${task.assigned_to_name || '未割当'}
                        </div>
                        <div class="task-date ${isOverdue ? 'overdue' : ''}">
                            <span class="icon-calendar"></span>
                            ${task.planned_date ? formatDate(task.planned_date) : '期限なし'}
                        </div>
                    </div>
                    <div class="task-flags">
                        ${task.is_technical_work == '1' ? '<span class="flag technical">技術作業</span>' : ''}
                        ${task.has_manual == '1' ? '<span class="flag manual">📚 マニュアルあり</span>' : ''}
                    </div>
                </div>
            `;
            
            return item;
        }

        // タスク編集
        async function editTask(taskId) {
            try {
                console.log('タスク編集開始:', taskId);
                
                // ユーザー一覧を先に読み込む
                await loadUsers();
                
                const task = filteredTasks.find(t => t.id == taskId);
                if (!task) {
                    console.error('タスクが見つかりません:', taskId);
                    showMessage('タスクが見つかりません', 'error');
                    return;
                }

                console.log('編集対象タスク:', task);
                console.log('assigned_to 値:', task.assigned_to);

                // タスク詳細を取得
                const response = await fetch(`api.php?path=tasks/${taskId}`);
                const data = await response.json();
                
                console.log('タスク詳細API応答:', data);
                
                if (data.success && data.task) {
                    const taskData = data.task;
                    console.log('API取得タスク assigned_to:', taskData.assigned_to);
                    
                    // モーダルにデータを設定
                    console.log('=== タスク編集データ設定開始 ===');
                    console.log('API取得タスクデータ:', taskData);
                    
                    document.getElementById('taskId').value = taskData.id;
                    console.log('タスクID設定:', taskData.id);
                    
                    document.getElementById('taskTitle').textContent = taskData.task_name || taskData.name;
                    console.log('タスクタイトル設定:', taskData.task_name || taskData.name);
                    
                    // ステータス設定
                    console.log('API取得タスク status:', taskData.status);
                    document.getElementById('taskStatus').value = taskData.status;
                    console.log('ステータスフィールド設定後の値:', document.getElementById('taskStatus').value);
                    
                    // 期限フィールドの設定
                    const plannedDate = taskData.planned_date || '';
                    console.log('API取得タスク planned_date:', taskData.planned_date);
                    console.log('期限フィールドに設定する値:', plannedDate);
                    document.getElementById('taskDueDate').value = plannedDate;
                    console.log('期限フィールド設定後の値:', document.getElementById('taskDueDate').value);
                    
                    document.getElementById('taskContentDisplay').textContent = taskData.template_content || '内容なし';
                    console.log('=== タスク編集データ設定完了 ===');
                    
                    // メタ情報表示
                    document.getElementById('taskPhase').textContent = task.phase_name || '未分類';
                    document.getElementById('taskOrder').textContent = task.task_order || '0';
                    document.getElementById('taskTechnical').textContent = task.is_technical_work == '1' ? 'はい' : 'いいえ';
                    document.getElementById('taskManualInfo').textContent = task.has_manual == '1' ? 'あり' : 'なし';
                    await loadTaskManuals(taskData.task_name || taskData.name);
                    
                    // 担当者設定（ユーザー読み込み後に設定）
                    console.log('API取得タスク assigned_to:', taskData.assigned_to);
                    console.log('API取得タスク assigned_to_name:', taskData.assigned_to_name);
                    
                    if (taskData.assigned_to) {
                        console.log('担当者を設定中:', taskData.assigned_to);
                        document.getElementById('taskAssignee').value = taskData.assigned_to;
                        console.log('担当者フィールド設定後の値:', document.getElementById('taskAssignee').value);
                    } else {
                        console.log('担当者が未設定');
                        document.getElementById('taskAssignee').value = '';
                        console.log('担当者フィールドを空に設定');
                    }
                    
                    // メモ履歴読み込み
                    await loadTaskNotes(taskId);
                    
                    // メンション機能のイベントリスナー設定
                    setupNoteInputEvents();
                    
                    // モーダル表示
                    document.getElementById('taskModal').style.display = 'block';
            } else {
                    console.error('タスク詳細読み込みエラー:', data.error);
                    showMessage('タスク詳細の読み込みに失敗しました', 'error');
                }
            } catch (error) {
                console.error('タスク編集エラー:', error);
                showMessage('タスク編集中にエラーが発生しました', 'error');
            }
        }

        // ユーザー一覧読み込み
        async function loadUsers() {
            try {
                const taskAssigneeSelect = document.getElementById('taskAssignee');
                const currentValue = taskAssigneeSelect.value; // 現在の値を保存
                
                console.log('ユーザー一覧読み込み中..., 現在の値:', currentValue);
                
                const response = await fetch('api.php?path=users');
                const data = await response.json();
                
                console.log('ユーザーAPI応答:', data);
                
                if (data.success && data.users) {
                    allUsers = data.users;
                    
                    // ドロップダウンを再構築
                    taskAssigneeSelect.innerHTML = '<option value="">未割当</option>';
                    
                    data.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.name;
                        taskAssigneeSelect.appendChild(option);
                    });
                    
                    // 保存していた値を復元
                    if (currentValue) {
                        taskAssigneeSelect.value = currentValue;
                        console.log('担当者値を復元:', currentValue, '→', taskAssigneeSelect.value);
                    }
                    
                    console.log(`${data.users.length}人のユーザーを読み込みました`);
            } else {
                    console.error('ユーザー読み込みエラー:', data.error);
                }
            } catch (error) {
                console.error('ユーザー読み込みエラー:', error);
            }
        }

        // タスクメモ読み込み
        async function loadTaskNotes(taskId) {
            try {
                console.log('loadTaskNotes called with taskId:', taskId);
                const response = await fetch(`api.php?path=tasks/${taskId}/notes&t=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();
                
                console.log('loadTaskNotes response:', data);
                
                const notesHistory = document.getElementById('notesHistory');
                
                if (data.success && data.notes && data.notes.length > 0) {
                    console.log('Found notes:', data.notes);
                    console.log('Number of notes found:', data.notes.length);
                    notesHistory.innerHTML = '';
                    data.notes.forEach((note, index) => {
                        console.log(`Processing note ${index + 1}:`, note);
                        const noteItem = document.createElement('div');
                        noteItem.className = 'note-item';
                        noteItem.setAttribute('data-note-id', note.id);
                        noteItem.innerHTML = `
                            <div class="note-header">
                                <div class="note-info">
                                    <span class="note-user">${note.user_name || '不明'}</span>
                                    <span class="note-date">${formatDateTime(note.created_at)}</span>
                                </div>
                                <div class="note-actions">
                                    <button type="button" class="btn-edit-note" onclick="editNote(${note.id})" title="編集">✏️</button>
                                    <button type="button" class="btn-delete-note" onclick="deleteNote(${note.id})" title="削除">🗑️</button>
                                </div>
                            </div>
                            <div class="note-content" id="note-content-${note.id}">${formatNoteContent(note.note)}</div>
                            <div class="note-edit-form" id="note-edit-${note.id}" style="display: none;">
                                <textarea class="note-edit-textarea" id="note-edit-text-${note.id}">${note.note}</textarea>
                                <div class="note-edit-actions">
                                    <button type="button" class="btn btn-primary btn-sm" onclick="saveNoteEdit(${note.id})">保存</button>
                                    <button type="button" class="btn btn-secondary btn-sm" onclick="cancelNoteEdit(${note.id})">キャンセル</button>
                                </div>
                            </div>
                        `;
                        notesHistory.appendChild(noteItem);
                    });
            } else {
                    console.log('No notes found or error:', data);
                    notesHistory.innerHTML = '<div class="note-item">メモはありません</div>';
                }
            } catch (error) {
                console.error('メモ読み込みエラー:', error);
                document.getElementById('notesHistory').innerHTML = '<div class="note-item">メモの読み込みに失敗しました</div>';
            }
        }

        // タスク名に紐づくマニュアル一覧を読み込み、表示/ダウンロードリンクを生成
        async function loadTaskManuals(taskName) {
            try {
                const linksWrap = document.getElementById('taskManualLinks');
                const list = document.getElementById('taskManualList');
                if (!linksWrap || !list) return;

                // タスク名でフィルタして取得（DBから確実に該当データのみ）
                const q = encodeURIComponent(taskName || '');
                const res = await fetch(`api.php?path=manuals&task_name=${q}&t=${Date.now()}`, { cache: 'no-store' });
                const data = await res.json();
                if (!data.success || !Array.isArray(data.manuals)) {
                    linksWrap.style.display = 'none';
                    list.innerHTML = '';
                    return;
                }

                const manuals = data.manuals;
                if (manuals.length === 0) {
                    linksWrap.style.display = 'none';
                    list.innerHTML = '';
                    return;
                }

                list.innerHTML = manuals.map(m => {
                    const id = m.id;
                    const name = m.original_name || m.file_name;
                    const sizeKb = m.file_size ? Math.round(m.file_size / 1024) + 'KB' : '';
                    const viewUrl = `api.php?path=admin/manuals/${id}`;
                    const dlUrl = `api.php?path=admin/manuals/${id}&download=1`;
                    return `
                        <div class="manual-link" style="margin:4px 0;">
                            <a href="${viewUrl}" target="_blank" rel="noopener">📄 表示</a>
                            <span style="margin: 0 6px; color:#adb5bd;">|</span>
                            <a href="${dlUrl}">⬇︎ ダウンロード</a>
                            <span style="margin-left:8px; color:#6c757d;">${name}${sizeKb ? ' ('+sizeKb+')' : ''}</span>
                        </div>`;
                }).join('');
                linksWrap.style.display = 'block';
            } catch (e) {
                console.warn('マニュアル読み込みエラー:', e);
                const linksWrap = document.getElementById('taskManualLinks');
                const list = document.getElementById('taskManualList');
                if (linksWrap && list) {
                    linksWrap.style.display = 'none';
                    list.innerHTML = '';
                }
            }
        }

        // メンション機能の変数
        let mentionStartPos = -1;
        let currentMentionQuery = '';
        let selectedSuggestionIndex = -1;

        // メモ入力のイベントリスナー設定
        function setupNoteInputEvents() {
            const noteInput = document.getElementById('newNote');
            if (noteInput) {
                noteInput.addEventListener('input', handleNoteInput);
                noteInput.addEventListener('keydown', handleNoteKeydown);
                
                // blurイベントを遅延実行して、候補リストのクリックを妨げないようにする
                noteInput.addEventListener('blur', (e) => {
                    setTimeout(() => {
                        hideUserSuggestions();
                    }, 150);
                });
            }
        }

        // メモ入力の処理
        function handleNoteInput(event) {
            const textarea = event.target;
            const cursorPos = textarea.selectionStart;
            const text = textarea.value;
            
            // @で始まる文字列を検索（日本語文字も含む）
            const mentionMatch = text.substring(0, cursorPos).match(/@([^\s]*)$/);
            
            if (mentionMatch) {
                mentionStartPos = cursorPos - mentionMatch[0].length;
                currentMentionQuery = mentionMatch[1];
                showUserSuggestions(currentMentionQuery, mentionStartPos);
            } else {
                hideUserSuggestions();
            }
        }

        // キーボードイベントの処理
        function handleNoteKeydown(event) {
            const suggestions = document.getElementById('userSuggestions');
            if (suggestions.style.display === 'none') return;

            const suggestionItems = suggestions.querySelectorAll('.suggestion-item');
            
            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestionItems.length - 1);
                    updateSuggestionSelection();
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSuggestionSelection();
                    break;
                case 'Enter':
                    event.preventDefault();
                    if (selectedSuggestionIndex >= 0) {
                        selectUserSuggestion(suggestionItems[selectedSuggestionIndex]);
                    }
                    break;
                case 'Escape':
                    hideUserSuggestions();
                    break;
            }
        }

        // ユーザー候補の表示
        function showUserSuggestions(query, position) {
            const suggestions = document.getElementById('userSuggestions');
            const filteredUsers = allUsers.filter(user => 
                user.name.toLowerCase().includes(query.toLowerCase())
            );

            console.log('showUserSuggestions called:', {
                query: query,
                position: position,
                allUsers: allUsers,
                filteredUsers: filteredUsers
            });

            if (filteredUsers.length === 0) {
                hideUserSuggestions();
                return;
            }

            suggestions.innerHTML = '';
            filteredUsers.forEach((user, index) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.setAttribute('data-user-name', user.name);
                item.innerHTML = `
                    <span class="user-name">${user.name}</span>
                    <span class="user-role">${getRoleText(user.role)}</span>
                `;
                
                // より確実なクリックイベントの実装
                item.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('User suggestion mousedown:', user.name);
                });
                
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('User suggestion clicked:', user.name);
                    selectUserSuggestion(item);
                });
                
                // タッチイベントも追加（モバイル対応）
                item.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('User suggestion touchend:', user.name);
                    selectUserSuggestion(item);
                });
                
                suggestions.appendChild(item);
            });
            
            // イベント委譲も追加
            suggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (item) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('User suggestion clicked via delegation:', item.getAttribute('data-user-name'));
                    selectUserSuggestion(item);
                }
            });

            selectedSuggestionIndex = 0;
            updateSuggestionSelection();
            suggestions.style.display = 'block';
        }

        // 候補選択の更新
        function updateSuggestionSelection() {
            const suggestions = document.getElementById('userSuggestions');
            const items = suggestions.querySelectorAll('.suggestion-item');
            
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedSuggestionIndex);
            });
        }

        // ユーザー候補の選択
        function selectUserSuggestion(selectedItem) {
            const textarea = document.getElementById('newNote');
            const userName = selectedItem.getAttribute('data-user-name') || selectedItem.querySelector('.user-name').textContent;
            const currentPos = textarea.selectionStart;
            const beforeMention = textarea.value.substring(0, mentionStartPos);
            const afterMention = textarea.value.substring(currentPos);
            
            console.log('selectUserSuggestion called:', {
                userName: userName,
                mentionStartPos: mentionStartPos,
                currentPos: currentPos,
                beforeMention: beforeMention,
                afterMention: afterMention,
                originalValue: textarea.value
            });
            
            // メンション部分を置き換え
            const newValue = beforeMention + '@' + userName + ' ' + afterMention;
            textarea.value = newValue;
            
            // カーソル位置を調整（メンションの後に配置）
            const newCursorPos = beforeMention.length + userName.length + 2;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            
            console.log('Text updated:', {
                newValue: newValue,
                newCursorPos: newCursorPos
            });
            
            // メンションが追加された場合、要確認ステータスに自動変更
            const statusSelect = document.getElementById('taskStatus');
            if (statusSelect && statusSelect.value !== 'needs_confirmation') {
                console.log('メンションが追加されたため、要確認ステータスに自動変更');
                console.log('変更前のステータス:', statusSelect.value);
                statusSelect.value = 'needs_confirmation';
                console.log('変更後のステータス:', statusSelect.value);
                
                // 視覚的なフィードバック
                statusSelect.style.backgroundColor = '#fff5f5';
                statusSelect.style.borderColor = '#ff6b6b';
                setTimeout(() => {
                    statusSelect.style.backgroundColor = '';
                    statusSelect.style.borderColor = '';
                }, 2000);
            } else {
                console.log('既に要確認ステータスまたはステータス選択要素が見つかりません');
            }
            
            hideUserSuggestions();
        }

        // ユーザー候補の非表示
        function hideUserSuggestions() {
            const suggestions = document.getElementById('userSuggestions');
            suggestions.style.display = 'none';
            selectedSuggestionIndex = -1;
        }

        // メモ内容のフォーマット（メンションをハイライト）
        function formatNoteContent(content) {
            if (!content) return '';
            
            // @ユーザー名 のパターンを検索してハイライト
            return content.replace(/@(\w+)/g, '<span class="mention">@$1</span>');
        }

        // メモ編集開始
        function editNote(noteId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('editNote called with noteId:', noteId);
            
            // 編集フォームを表示
            document.getElementById(`note-edit-${noteId}`).style.display = 'block';
            document.getElementById(`note-content-${noteId}`).style.display = 'none';
            
            // テキストエリアにフォーカス
            const textarea = document.getElementById(`note-edit-text-${noteId}`);
            textarea.focus();
            textarea.select();
        }

        // メモ編集キャンセル
        function cancelNoteEdit(noteId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('cancelNoteEdit called with noteId:', noteId);
            
            // 編集フォームを非表示
            document.getElementById(`note-edit-${noteId}`).style.display = 'none';
            document.getElementById(`note-content-${noteId}`).style.display = 'block';
        }

        // メモ編集保存
        async function saveNoteEdit(noteId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const content = document.getElementById(`note-edit-text-${noteId}`).value.trim();
            
            console.log('saveNoteEdit called with noteId:', noteId, 'content:', content);
            
            if (!content) {
                showMessage('メモ内容を入力してください', 'error');
                return;
            }
            
            try {
                const requestData = {
                    note: content
                };
                console.log('Sending edit request to:', `api.php?path=notes/${noteId}`);
                console.log('Request data:', requestData);
                
                const response = await fetch(`api.php?path=notes/${noteId}&t=${Date.now()}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('Edit response status:', response.status);
                const data = await response.json();
                console.log('Edit response data:', data);
                
                if (data.success) {
                    // 即座にメモ内容を更新
                    document.getElementById(`note-content-${noteId}`).innerHTML = formatNoteContent(content);
                    
                    // 編集フォームを非表示
                    document.getElementById(`note-edit-${noteId}`).style.display = 'none';
                    document.getElementById(`note-content-${noteId}`).style.display = 'block';
                    
                    showMessage('メモを更新しました', 'success');
                } else {
                    console.error('メモ更新エラー:', data.error || data.message);
                    showMessage('メモの更新に失敗しました: ' + (data.error || data.message), 'error');
                }
            } catch (error) {
                console.error('メモ更新エラー:', error);
                showMessage('メモの更新中にエラーが発生しました', 'error');
            }
        }

        // メモ削除
        async function deleteNote(noteId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('deleteNote called with noteId:', noteId);
            
            if (!confirm('このメモを削除しますか？')) {
                return;
            }
            
            try {
                console.log('Sending delete request to:', `api.php?path=notes/${noteId}`);
                
                const response = await fetch(`api.php?path=notes/${noteId}&t=${Date.now()}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                console.log('Delete response status:', response.status);
                const data = await response.json();
                console.log('Delete response data:', data);
                
                if (data.success) {
                    // 即座にメモ要素を削除（アニメーション付き）
                    const noteElement = document.querySelector(`[data-note-id="${noteId}"]`);
                    if (noteElement) {
                        // フェードアウトアニメーション
                        noteElement.style.transition = 'all 0.3s ease';
                        noteElement.style.opacity = '0';
                        noteElement.style.transform = 'translateX(-20px)';
                        
                        setTimeout(() => {
                            noteElement.remove();
                        }, 300);
                    }
                    
                    showMessage('メモを削除しました', 'success');
                } else {
                    console.error('メモ削除エラー:', data.error || data.message);
                    showMessage('メモの削除に失敗しました: ' + (data.error || data.message), 'error');
                }
            } catch (error) {
                console.error('メモ削除エラー:', error);
                showMessage('メモの削除中にエラーが発生しました', 'error');
            }
        }

        // メモ追加
        async function addNote(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const taskId = document.getElementById('taskId').value;
            const content = document.getElementById('newNote').value.trim();
            
            console.log('addNote called with taskId:', taskId, 'content:', content);
            
            if (!content) {
                showMessage('メモ内容を入力してください', 'error');
                return;
            }
            
            if (!taskId) {
                showMessage('タスクIDが取得できません', 'error');
                return;
            }
            
            try {
                const requestData = {
                    note: content
                };
                console.log('Sending request to:', `api.php?path=tasks/${taskId}/notes`);
                console.log('Request data:', requestData);
                
                const response = await fetch(`api.php?path=tasks/${taskId}/notes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);
                
                if (data.success) {
                    console.log('メモ追加成功、即座にUIに反映中...');
                    
                    // 入力フィールドをクリア
                    document.getElementById('newNote').value = '';
                    
                    // 即座にUIに新しいメモを追加
                    addMemoToUI(content, data.note_id || Date.now());
                    
                    console.log('メモをUIに即座に反映完了');
                    showMessage('メモを追加しました', 'success');
                } else {
                    console.error('メモ追加エラー:', data.error || data.message);
                    showMessage('メモの追加に失敗しました: ' + (data.error || data.message), 'error');
                }
            } catch (error) {
                console.error('メモ追加エラー:', error);
                showMessage('メモの追加中にエラーが発生しました', 'error');
            }
        }

        // タスク保存（リトライ機能付き）
        async function saveTask(retryCount = 0) {
            const maxRetries = 3;
            
            // 重複実行防止
            if (window.isSavingTask) {
                console.log('タスク保存が既に実行中です');
                return;
            }
            
            window.isSavingTask = true;
            
            try {
                const taskId = document.getElementById('taskId').value;
                
                if (!taskId) {
                    showMessage('タスクIDが取得できません', 'error');
                    return;
                }
                
                // 各フィールドの値を個別に取得・確認
                const statusValue = document.getElementById('taskStatus').value;
                const assigneeValue = document.getElementById('taskAssignee').value;
                const dateValue = document.getElementById('taskDueDate').value;
                
                console.log('=== タスク保存データ取得 (試行 ' + (retryCount + 1) + ') ===');
                console.log('タスクID:', taskId);
                console.log('ステータスフィールドの値:', statusValue);
                console.log('担当者フィールドの値:', assigneeValue);
                console.log('期限フィールドの値:', dateValue);
                
                const formData = {
                    task_id: taskId,
                    status: statusValue,
                    assigned_to: assigneeValue || null,
                    planned_date: dateValue || null
                };

                console.log('送信するタスク保存データ:', formData);

                // 保存ボタンを無効化
                const saveButton = document.querySelector('button[onclick="saveTask()"]');
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = '保存中...';
                }

                // リクエストタイムアウトを設定
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒タイムアウト

                const response = await fetch('api.php?path=tasks/update', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                console.log('タスク保存レスポンス:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('タスク保存レスポンスデータ:', data);

                if (data.success) {
                    console.log('タスク保存成功、プロジェクトを再読み込み中...');
                    showMessage('タスクを更新しました', 'success');
                    closeTaskModal();
                    
                    // プロジェクトデータを再読み込み
                    if (currentProject) {
                        await loadProject(currentProject.id);
                        console.log('プロジェクト再読み込み完了');
                        
                        // 保存後のデータ確認
                        const updatedTask = allTasks.find(t => t.id == taskId);
                        if (updatedTask) {
                            console.log('保存後のタスクデータ確認:', {
                                id: updatedTask.id,
                                status: updatedTask.status,
                                assigned_to: updatedTask.assigned_to,
                                planned_date: updatedTask.planned_date
                            });
                        }
                    }
                } else {
                    throw new Error(data.error || data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('タスク保存エラー (試行 ' + (retryCount + 1) + '):', error);
                
                if (retryCount < maxRetries) {
                    console.log('リトライします... (' + (retryCount + 1) + '/' + maxRetries + ')');
                    await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1))); // 指数バックオフ
                    return saveTask(retryCount + 1);
                } else {
                    showMessage('タスクの保存に失敗しました: ' + error.message, 'error');
                }
            } finally {
                // 保存ボタンを復元
                const saveButton = document.querySelector('button[onclick="saveTask()"]');
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = '保存';
                }
                
                // フラグをリセット
                window.isSavingTask = false;
            }
        }

        // 進捗更新
        function updateProgress() {
            if (!filteredTasks || filteredTasks.length === 0) {
                document.getElementById('totalTasks').textContent = '0';
                document.getElementById('completedTasks').textContent = '0';
                document.getElementById('inProgressTasks').textContent = '0';
                document.getElementById('needsConfirmationTasks').textContent = '0';
                document.getElementById('overdueTasks').textContent = '0';
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('progressText').textContent = '0%';
                return;
            }

            const total = filteredTasks.length;
            const completed = filteredTasks.filter(task => task.status === 'completed').length;
            const inProgress = filteredTasks.filter(task => task.status === 'in_progress').length;
            const needsConfirmation = filteredTasks.filter(task => task.status === 'needs_confirmation').length;
            const overdue = filteredTasks.filter(task => {
                return task.planned_date && new Date(task.planned_date) < new Date() && task.status !== 'completed';
            }).length;

            const progressPercent = total > 0 ? Math.round((completed / total) * 100) : 0;

            document.getElementById('totalTasks').textContent = total;
            document.getElementById('completedTasks').textContent = completed;
            document.getElementById('inProgressTasks').textContent = inProgress;
            document.getElementById('overdueTasks').textContent = overdue;
            
            // 要確認タスクの表示（要素が存在する場合のみ）
            const needsConfirmationElement = document.getElementById('needsConfirmationTasks');
            if (needsConfirmationElement) {
                needsConfirmationElement.textContent = needsConfirmation;
            }
            document.getElementById('progressFill').style.width = `${progressPercent}%`;
            document.getElementById('progressText').textContent = `${progressPercent}%`;
        }

        // 新規プロジェクトモーダル関連
        async function openNewProjectModal() {
            try {
                console.log('=== 新規プロジェクトモーダル表示開始 ===');
                
                // クライアント、フェーズ、テンプレートを並行読み込み
                console.log('データ読み込み開始...');
                await Promise.allSettled([
                    loadClients(),
                    loadPhases(),
                    loadTemplates()
                ]);
                
                console.log('データ読み込み完了');
                console.log('allClients:', allClients);
                console.log('allPhases:', allPhases);
                console.log('allTemplates:', allTemplates);
                
                // 発注者セレクトボックスが正しく設定されているか確認
                const clientSelect = document.getElementById('newProjectClient');
                if (clientSelect) {
                    console.log('新規プロジェクト発注者セレクトボックス:', clientSelect);
                    console.log('選択肢数:', clientSelect.options.length);
                } else {
                    console.error('newProjectClient セレクトボックスが見つかりません');
                }
                
                document.getElementById('newProjectModal').style.display = 'block';
                markNewProjectModalOpen(true);
                // 途中の下書きがあれば復元
                loadNewProjectDraft();
                startNewProjectModalGuard();
                console.log('新規プロジェクトモーダル表示完了');
            } catch (error) {
                console.error('新規プロジェクトモーダル表示エラー:', error);
                showMessage('モーダルの表示に失敗しました', 'error');
            }
        }

        function closeNewProjectModal() {
            document.getElementById('newProjectModal').style.display = 'none';
            document.getElementById('newProjectForm').reset();
            markNewProjectModalOpen(false);
            stopNewProjectModalGuard();
        }

        // クライアント読み込み
        async function loadClients() {
            try {
                console.log('クライアント読み込み開始...');
                const response = await fetch(`api.php?path=clients&t=${Date.now()}`, { cache: 'no-store' });
                console.log('クライアントAPI応答:', response.status);
                
                const data = await response.json();
                console.log('クライアントデータ:', data);
                
                if (data.success && data.clients) {
                    allClients = data.clients;
                    console.log('クライアント取得成功:', allClients);
                    populateClientSelect();
                } else {
                    console.error('クライアント読み込み失敗:', data.error || 'データが見つかりません');
                }
            } catch (error) {
                console.error('クライアント読み込みエラー:', error);
            }
        }

        function populateClientSelect() {
            console.log('populateClientSelect called with allClients:', allClients);
            const selects = ['newProjectClient', 'editProjectClient'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                console.log(`Select element ${selectId}:`, select);
                if (select) {
                    select.innerHTML = '<option value="">発注者を選択</option>';
                    allClients.forEach(client => {
                        const option = document.createElement('option');
                        option.value = client.id;
                        option.textContent = client.name;
                        select.appendChild(option);
                        console.log(`Added client option: ${client.name} (ID: ${client.id})`);
                    });
                    console.log(`Client select ${selectId} populated with ${allClients.length} clients`);
                } else {
                    console.error(`Select element ${selectId} not found`);
                }
            });
        }

        // フェーズ読み込み
        async function loadPhases() {
            try {
                const response = await fetch(`api.php?path=phases&t=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();
                
                if (data.success && data.phases) {
                    allPhases = data.phases;
                    setupTemplateFilters();
                }
            } catch (error) {
                console.error('フェーズ読み込みエラー:', error);
            }
        }

        // テンプレートフィルター設定
        function setupTemplateFilters() {
            const filtersContainer = document.getElementById('templateFilters');
            filtersContainer.innerHTML = '';

            // 全体フィルターは非表示（最初のフェーズをデフォルト選択）
            if (allPhases.length > 0) {
                // 各フェーズフィルター
                allPhases.forEach((phase, index) => {
                    const btn = document.createElement('button');
                    btn.className = index === 0 ? 'filter-btn active' : 'filter-btn';
                    btn.textContent = phase.name;
                    btn.dataset.phaseId = phase.id;
                    btn.addEventListener('click', function() {
                        filterTemplates(parseInt(this.dataset.phaseId));
                    });
                    filtersContainer.appendChild(btn);
                });
                
                // 最初のフェーズのテンプレートを表示
                if (allTemplates.length > 0) {
                    filterTemplates(allPhases[0].id);
                }
            }
        }

        // テンプレート読み込み
        async function loadTemplates() {
            try {
                console.log('テンプレート読み込み開始...');
                const response = await fetch(`api.php?path=templates&t=${Date.now()}`, { cache: 'no-store' });
                console.log('テンプレートAPI応答:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('テンプレートデータ:', data);
                
                if (data.success && data.templates) {
                    allTemplates = data.templates;
                    console.log('テンプレート取得成功:', allTemplates);
                    
                    // フェーズが既に読み込まれている場合は、最初のフェーズのテンプレートを表示
                    if (allPhases.length > 0) {
                        filterTemplates(allPhases[0].id);
                    } else {
                        displayTemplates(allTemplates);
                    }
                } else {
                    console.error('テンプレート読み込み失敗:', data.error || data.message || 'データが見つかりません');
                    allTemplates = [];
                    displayTemplates([]);
                }
            } catch (error) {
                console.error('テンプレート読み込みエラー:', error);
                allTemplates = [];
                displayTemplates([]);
            }
        }

        // テンプレートフィルタリング
        function filterTemplates(phaseId) {
            console.log('filterTemplates called with phaseId:', phaseId);
            
            // フェーズIDからフェーズ名を取得
            const phase = allPhases.find(p => p.id == phaseId);
            if (!phase) {
                console.error('Phase not found for ID:', phaseId);
                return;
            }
            
            const phaseName = phase.name;
            console.log('Found phase name:', phaseName);
            
            // フィルターボタンのアクティブ状態更新
            document.querySelectorAll('#templateFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // クリックされたボタンをアクティブにする
            const clickedBtn = document.querySelector(`#templateFilters .filter-btn[data-phase-id="${phaseId}"]`);
            if (clickedBtn) {
                clickedBtn.classList.add('active');
            }

            // フェーズ名でテンプレートをフィルタリング
            const filtered = allTemplates.filter(template => template.phase_name === phaseName);
            console.log('Filtered templates for phase', phaseName, ':', filtered);
            displayTemplates(filtered);
        }

        // テンプレート表示
        function displayTemplates(templates) {
            console.log('displayTemplates called with templates:', templates);
            if (templates && templates.length > 0) {
                console.log('First template structure:', templates[0]);
                console.log('Template properties:', Object.keys(templates[0]));
            }
            const container = document.getElementById('templateGroups');
            console.log('Template container element:', container);
            
            if (!container) {
                console.error('Template container element not found');
                return;
            }
            
            container.innerHTML = '';

            if (!templates || templates.length === 0) {
                console.log('No templates to display');
                container.innerHTML = '<div class="empty">テンプレートがありません</div>';
                return;
            }
            
            console.log(`Displaying ${templates.length} templates`);

            // フェーズごとにグループ化
            const templatesByPhase = {};
            templates.forEach(template => {
                const phaseName = template.phase_name || '未分類';
                
                if (!templatesByPhase[phaseName]) {
                    templatesByPhase[phaseName] = [];
                }
                templatesByPhase[phaseName].push(template);
            });

            // フェーズごとに表示
            Object.entries(templatesByPhase).forEach(([phaseName, phaseTemplates]) => {
                const phaseGroup = document.createElement('div');
                phaseGroup.className = 'template-group';
                
                const phaseTitle = document.createElement('h5');
                phaseTitle.className = 'phase-title';
                phaseTitle.textContent = phaseName;
                phaseGroup.appendChild(phaseTitle);
                
                const templateItems = document.createElement('div');
                templateItems.className = 'template-items';
                
                phaseTemplates.forEach(template => {
                    console.log('Creating template item for:', template);
                    console.log('Template task_name:', template.task_name);
                    console.log('Template content:', template.content);
                    
                    const isSelected = selectedTemplateIds.has(template.id.toString());
                    console.log('Template', template.id, 'is selected:', isSelected);
                    
                    const item = document.createElement('div');
                    item.className = 'template-item';
                    item.innerHTML = `
                        <label class="template-checkbox">
                            <input type="checkbox" name="templates" value="${template.id}" ${isSelected ? 'checked' : ''}>
                            <div class="template-info">
                                <div class="template-name">${template.task_name || 'テンプレート名なし'}</div>
                                <div class="template-content">${template.content || ''}</div>
                                <div class="template-flags">
                                    ${template.is_technical_work == '1' ? '<span class="flag technical">技術作業</span>' : ''}
                                    ${template.has_manual == '1' ? '<span class="flag manual">マニュアルあり</span>' : ''}
                                </div>
                            </div>
                        </label>
                    `;
                    
                    // チェックボックスの変更イベントを追加
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedTemplateIds.add(template.id.toString());
                        } else {
                            selectedTemplateIds.delete(template.id.toString());
                        }
                        saveSelectedTemplatesToStorage();
                        updateSelectedCount();
                        console.log('Selected templates:', Array.from(selectedTemplateIds));
                    });
                    
                    templateItems.appendChild(item);
                });
                
                phaseGroup.appendChild(templateItems);
                container.appendChild(phaseGroup);
            });

            updateSelectedCount();
        }

        // 選択数更新
        function updateSelectedCount() {
            const count = selectedTemplateIds.size;
            document.getElementById('selectedCount').textContent = count;
            console.log('Updated selected count:', count);
        }

        // すべて選択
        function selectAllTemplates() {
            const activePhaseBtn = document.querySelector('#templateFilters .filter-btn.active');
            const activePhaseText = activePhaseBtn.textContent;
            
            // アクティブなフェーズのテンプレートのみ選択
            const phaseGroup = Array.from(document.querySelectorAll('.template-group')).find(group => {
                const title = group.querySelector('.phase-title');
                return title && title.textContent === activePhaseText;
            });
            
            if (phaseGroup) {
                phaseGroup.querySelectorAll('input[name="templates"]').forEach(checkbox => {
                    checkbox.checked = true;
                    selectedTemplateIds.add(checkbox.value);
                });
            }
            
            saveSelectedTemplatesToStorage();
            updateSelectedCount();
            console.log('All templates selected for phase:', activePhaseText);
            console.log('Selected templates:', Array.from(selectedTemplateIds));
        }

        // すべて解除
        function deselectAllTemplates() {
            const activePhaseBtn = document.querySelector('#templateFilters .filter-btn.active');
            const activePhaseText = activePhaseBtn ? activePhaseBtn.textContent : null;
            
            // アクティブなフェーズのテンプレートのみ解除
            const phaseGroup = Array.from(document.querySelectorAll('.template-group')).find(group => {
                const title = group.querySelector('.phase-title');
                return title && (!activePhaseText || title.textContent === activePhaseText);
            });
            
            if (phaseGroup) {
                phaseGroup.querySelectorAll('input[name="templates"]').forEach(checkbox => {
                    checkbox.checked = false;
                    selectedTemplateIds.delete(checkbox.value);
                });
            }
            
            saveSelectedTemplatesToStorage();
            updateSelectedCount();
            console.log('All templates deselected for phase:', activePhaseText);
            console.log('Selected templates:', Array.from(selectedTemplateIds));
        }

        // プロジェクト作成
        async function createProject() {
            try {
                const form = document.getElementById('newProjectForm');
                const formData = new FormData(form);
                
                // フォームデータの取得と検証
                const name = formData.get('name')?.trim();
                const clientId = formData.get('client_id');
                const startDate = formData.get('start_date');
                const endDate = formData.get('end_date');
                
                console.log('フォームデータ検証:');
                console.log('- プロジェクト名:', name);
                console.log('- 発注者ID:', clientId);
                console.log('- 開始日:', startDate);
                console.log('- 終了日:', endDate);
                
                // 必須フィールドの検証
                if (!name) {
                    showMessage('プロジェクト名を入力してください', 'error');
                    return;
                }
                
                if (!clientId) {
                    showMessage('発注者を選択してください', 'error');
                    return;
                }
                
                if (!startDate) {
                    showMessage('開始日を入力してください', 'error');
                    return;
                }
                
                if (!endDate) {
                    showMessage('終了日を入力してください', 'error');
                    return;
                }
                
                // 選択されたテンプレート（全フェーズ横断で保持しているSetから取得）
                const selectedTemplates = Array.from(selectedTemplateIds);

                if (selectedTemplates.length === 0) {
                    showMessage('少なくとも1つのテンプレートを選択してください', 'error');
                    return;
                }

                const projectData = {
                    name: name,
                    client_id: clientId,
                    start_date: startDate,
                    end_date: endDate,
                    templates: selectedTemplates
                };

                console.log('プロジェクト作成データ:', projectData);

                const response = await fetch('api.php?path=projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(projectData)
                });

                console.log('プロジェクト作成レスポンス:', response.status);

                const data = await response.json();
                console.log('プロジェクト作成レスポンスデータ:', data);

                if (data.success) {
                    console.log('プロジェクト作成成功');
                    showMessage('プロジェクトを作成しました', 'success');
                    closeNewProjectModal(); // 保存時のみクローズ
                    await loadProjects();
                    
                    // 新しく作成されたプロジェクトを選択
                    if (data.project_id) {
                        document.getElementById('projectSelect').value = data.project_id;
                        await loadProject(data.project_id);
                    }
                } else {
                    console.error('プロジェクト作成エラー:', data.error || data.message);
                    const errorMessage = data.error || data.message || '不明なエラーが発生しました';
                    showMessage('プロジェクトの作成に失敗しました: ' + errorMessage, 'error');
                }
            } catch (error) {
                console.error('プロジェクト作成エラー:', error);
                showMessage('プロジェクトの作成中にエラーが発生しました: ' + error.message, 'error');
            }
        }

        // プロジェクト編集
        async function editProject() {
            if (!currentProject) {
                showMessage('編集するプロジェクトが選択されていません', 'error');
                return;
            }

            try {
                // クライアント情報を読み込み
                await loadClients();
                
                // フォームにデータを設定
                document.getElementById('editProjectId').value = currentProject.id;
                document.getElementById('editProjectName').value = currentProject.name;
                document.getElementById('editProjectClient').value = currentProject.client_id;
                document.getElementById('editProjectStartDate').value = currentProject.start_date;
                document.getElementById('editProjectEndDate').value = currentProject.end_date || currentProject.target_end_date || '';
                document.getElementById('editProjectStatus').value = currentProject.status;
                
                document.getElementById('editProjectModal').style.display = 'block';
            } catch (error) {
                console.error('プロジェクト編集モーダル表示エラー:', error);
                showMessage('編集画面の表示に失敗しました', 'error');
            }
        }

        function closeEditProjectModal() {
            document.getElementById('editProjectModal').style.display = 'none';
        }

        // プロジェクト更新
        async function updateProject() {
            try {
                const formData = {
                    id: document.getElementById('editProjectId').value,
                    name: document.getElementById('editProjectName').value,
                    client_id: document.getElementById('editProjectClient').value,
                    start_date: document.getElementById('editProjectStartDate').value,
                    end_date: document.getElementById('editProjectEndDate').value,
                    status: document.getElementById('editProjectStatus').value
                };

                console.log('=== プロジェクト更新開始 ===');
                console.log('プロジェクト更新データ:', formData);
                console.log('送信するプロジェクトID:', formData.id);
                console.log('送信するプロジェクト名:', formData.name);
                console.log('送信するクライアントID:', formData.client_id);

                const response = await fetch(`api.php?path=projects/${formData.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                console.log('プロジェクト更新レスポンス:', response.status);

                const data = await response.json();
                console.log('プロジェクト更新レスポンスデータ:', data);

                if (data.success) {
                    console.log('プロジェクト更新成功');
                    showMessage('プロジェクトを更新しました', 'success');
                    closeEditProjectModal();
                    await loadProjects();
                    await loadProject(formData.id);
                    console.log('プロジェクト更新処理完了');
                } else {
                    console.error('プロジェクト更新エラー:', data.error || data.message);
                    showMessage('プロジェクトの更新に失敗しました: ' + (data.error || data.message || '不明なエラー'), 'error');
                }
            } catch (error) {
                console.error('プロジェクト更新エラー:', error);
                showMessage('プロジェクトの更新中にエラーが発生しました: ' + error.message, 'error');
            }
        }

        // プロジェクト削除
        function deleteProject() {
            if (!currentProject) {
                showMessage('削除するプロジェクトが選択されていません', 'error');
                return;
            }

            document.getElementById('deleteProjectName').textContent = currentProject.name;
            document.getElementById('deleteProjectModal').style.display = 'block';
        }

        function closeDeleteProjectModal() {
            document.getElementById('deleteProjectModal').style.display = 'none';
        }

        async function confirmDeleteProject() {
            try {
                const projectId = currentProject.id;
                console.log('プロジェクト削除実行:', projectId);

                const response = await fetch(`api.php?path=projects/${projectId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                console.log('削除API応答:', data);

                if (data.success) {
                    showMessage('プロジェクトを削除しました', 'success');
                    closeDeleteProjectModal();
                    hideProjectInfo();
                    // ローカルストレージからも削除
                    localStorage.removeItem('selectedProjectId');
                    await loadProjects();
                    document.getElementById('projectSelect').value = '';
                } else {
                    console.error('プロジェクト削除エラー:', data.error);
                    showMessage('プロジェクトの削除に失敗しました: ' + (data.error || '不明なエラー'), 'error');
                }
            } catch (error) {
                console.error('プロジェクト削除エラー:', error);
                showMessage('プロジェクトの削除中にエラーが発生しました', 'error');
            }
        }

        // プロジェクトデータ更新
        async function refreshProjectData() {
            if (!currentProject) {
                showMessage('更新するプロジェクトが選択されていません', 'error');
                return;
            }

            try {
                showMessage('データを更新中...', 'info');
                await loadProject(currentProject.id);
                showMessage('データを更新しました', 'success');
            } catch (error) {
                console.error('データ更新エラー:', error);
                showMessage('データの更新に失敗しました', 'error');
            }
        }

        // タスクモーダル関連
        function closeTaskModal() {
            document.getElementById('taskModal').style.display = 'none';
            document.getElementById('newNote').value = '';
        }

        // ユーティリティ関数
        function formatDate(dateString) {
            console.log('formatDate called with:', dateString);
            if (!dateString) {
                console.log('formatDate: empty dateString, returning empty string');
                return '';
            }
            const date = new Date(dateString);
            const formatted = date.toLocaleDateString('ja-JP');
            console.log('formatDate result:', formatted);
            return formatted;
        }

        function formatDateTime(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleString('ja-JP');
        }

        function getStatusText(status) {
            switch(status) {
                case 'not_started': return '未着手';
                case 'in_progress': return '進行中';
                case 'completed': return '完了';
                case 'needs_confirmation': return '要確認';
                case 'not_applicable': return '対象外';
                case 'active': return '進行中';
                case 'on_hold': return '保留';
                default: return status;
            }
        }

        // 確認対象者を取得
        function getConfirmationTarget(task) {
            console.log('getConfirmationTarget called with task:', task);
            
            // タスクのメモから@メンションを検索（日本語対応）
            if (task.notes) {
                console.log('タスクのメモを確認:', task.notes);
                
                // より柔軟なメンション検索（日本語、英数字、記号に対応）
                const mentionMatches = task.notes.match(/@([^\s@]+)/g);
                if (mentionMatches && mentionMatches.length > 0) {
                    // 最新のメンションを取得
                    const latestMention = mentionMatches[mentionMatches.length - 1];
                    const mentionedUser = latestMention.replace('@', '');
                    console.log('メンションされたユーザー:', mentionedUser);
                    return mentionedUser;
                }
            }
            
            // メモがない場合は担当者を確認対象とする
            if (task.assigned_to_name) {
                console.log('担当者を確認対象に設定:', task.assigned_to_name);
                return task.assigned_to_name;
            }
            
            // 担当者もない場合は管理者
            console.log('デフォルト確認対象: 管理者');
            return '管理者';
        }

        // 新しいメモを即座にUIに追加
        function addMemoToUI(content, noteId) {
            const notesHistory = document.getElementById('notesHistory');
            
            // 現在のユーザー名を取得（デフォルトは「井上直樹」）
            const currentUserName = '井上直樹'; // 実際の実装では認証情報から取得
            
            // 新しいメモアイテムを作成
            const noteItem = document.createElement('div');
            noteItem.className = 'note-item new-memo';
            noteItem.setAttribute('data-note-id', noteId);
            noteItem.innerHTML = `
                <div class="note-header">
                    <div class="note-info">
                        <span class="note-user">${currentUserName}</span>
                        <span class="note-date">${formatDateTime(new Date())}</span>
                    </div>
                    <div class="note-actions">
                        <button type="button" class="btn-edit-note" onclick="editNote(${noteId})" title="編集">✏️</button>
                        <button type="button" class="btn-delete-note" onclick="deleteNote(${noteId})" title="削除">🗑️</button>
                    </div>
                </div>
                <div class="note-content" id="note-content-${noteId}">${formatNoteContent(content)}</div>
                <div class="note-edit-form" id="note-edit-${noteId}" style="display: none;">
                    <textarea class="note-edit-textarea" id="note-edit-text-${noteId}">${content}</textarea>
                    <div class="note-edit-actions">
                        <button type="button" class="btn btn-primary btn-sm" onclick="saveNoteEdit(${noteId})">保存</button>
                        <button type="button" class="btn btn-secondary btn-sm" onclick="cancelNoteEdit(${noteId})">キャンセル</button>
                    </div>
                </div>
            `;
            
            // メモ一覧の先頭に追加
            if (notesHistory.firstChild) {
                notesHistory.insertBefore(noteItem, notesHistory.firstChild);
            } else {
                notesHistory.appendChild(noteItem);
            }
            
            // アニメーション効果を追加
            noteItem.style.opacity = '0';
            noteItem.style.transform = 'translateY(-10px)';
            setTimeout(() => {
                noteItem.style.transition = 'all 0.3s ease';
                noteItem.style.opacity = '1';
                noteItem.style.transform = 'translateY(0)';
            }, 10);
        }

        // ローディング表示/非表示
        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // メッセージ表示
        function showMessage(message, type = 'info') {
            const container = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;
            messageDiv.textContent = message;
            messageDiv.style.cssText = `
                background: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#4ecdc4' : '#667eea'};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                margin-bottom: 1rem;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                animation: slideInRight 0.3s ease;
            `;

            container.appendChild(messageDiv);

            // 3秒後に自動削除
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }

        // テンプレート選択数更新のイベントリスナー
        document.addEventListener('change', function(e) {
            if (e.target.name === 'templates') {
                updateSelectedCount();
            }
        });
    </script>
</body>
</html>
